# ВШЭ-Банк

## Описание проекта

Проект представляет собой консольное приложение для управления личными финансами с функциями:
- Создание, редактирование и удаление банковских счетов, категорий и операций
- Автоматическое обновление баланса при операциях
- Аналитика доходов и расходов
- Импорт и экспорт данных в форматах JSON и CSV
- Измерение производительности операций

## Функциональность


**Основные требования**:
- Создание, редактирование, удаление счетов
- Создание, редактирование, удаление категорий
- Создание, редактирование, удаление операций
- Автоматическое обновление баланса счетов

**Аналитика**:
- Подсчет разницы доходов и расходов за период
- Группировка операций по категориям
- Расширяемая архитектура для добавления новых видов аналитики

**Импорт/Экспорт**:
- Экспорт в JSON
- Экспорт в CSV
- Импорт из JSON
- Импорт из CSV

**Статистика**:
- Измерение времени выполнения пользовательских сценариев



## Инструкция по запуску

### Требования
- Java 21 или выше
- Gradle (или использовать Gradle Wrapper)

### Запуск через Gradle

1. Перейдите в директорию проекта:
```bash
cd homework/homework2
```

2. Запустите приложение:
```bash
./gradlew bootRun
```

Или на Windows:
```bash
gradlew.bat bootRun
```

### Сборка проекта

Для сборки JAR-файла:
```bash
./gradlew build
```

Запуск собранного JAR:
```bash
java -jar build/libs/hse.kpo.homework2-1.0.0.jar
```

## Реализованные паттерны GoF

### Factory
**Класс**: `EntityFactory`

**Назначение**: Централизованное создание доменных объектов с обязательной валидацией.

- Гарантирует, что все объекты создаются с правильными данными
- Предотвращает создание невалидных объектов (например, операции с отрицательной суммой)
- Устраняет дублирование кода валидации
- Следует принципу SRP - одно место для логики создания и валидации

### Facade
**Классы**: `BankAccountFacade`, `CategoryFacade`, `OperationFacade`, `AnalyticsFacade`

**Назначение**: Упрощенный интерфейс для работы с каждой доменной сущностью.

- Скрывает сложность взаимодействия между репозиториями и фабриками
- Предоставляет единую точку входа для CRUD операций
- Инкапсулирует бизнес-логику (например, автоматическое обновление баланса при создании операции)
- Упрощает использование системы для клиентского кода

### Command
**Классы**: `ConsoleCommand`, `CommandRegistry`, `command.impl`

**Назначение**: Инкапсуляция пользовательских сценариев как объектов.

- Позволяет параметризовать объекты выполняемыми действиями
- Упрощает логирование и аудит операций
- Облегчает применение декораторов для расширения функциональности

### Decorator
**Классы**: `CommandDecorator`, `TimingDecorator`

**Назначение**: Динамическое добавление функциональности командам (измерение времени выполнения).

- Позволяет добавлять функциональность без изменения исходного кода команд
- Следует принципу OCP (Open/Closed Principle)
- Легко добавить другие декораторы (логирование, кэширование и т.д.)
- Не требует изменения существующих классов команд

### Strategy
**Классы**: `AnalyticsStrategy`, `IncomeExpenseDifferenceStrategy`, `CategoryGroupingStrategy`

**Назначение**: Семейство взаимозаменяемых алгоритмов аналитики.

- Позволяет выбирать алгоритм аналитики во время выполнения
- Упрощает добавление новых видов аналитики
- Изолирует алгоритмы друг от друга
- Следует принципу SRP

### Template Method
**Классы**: `DataImporter`, `JsonImporter`, `CsvImporter`

**Назначение**: Определение скелета алгоритма импорта с делегированием специфичных шагов подклассам.

- Общая структура импорта одинакова
- Отличается только парсинг для разных форматов
- Устраняет дублирование кода
- Гарантирует выполнение всех необходимых шагов

### Visitor
**Классы**: `ExportVisitor`, `JsonExportVisitor`, `CsvExportVisitor`

**Назначение**: Разделение алгоритмов экспорта от структуры данных.

- Позволяет добавлять новые операции экспорта без изменения классов моделей
- Группирует связанные операции в одном классе
- Упрощает добавление новых форматов экспорта (XML, YAML и т.д.)
- Следует принципу OCP

### Singleton
**Классы**: Все `@Repository` и `@Service` классы

**Назначение**: Гарантия единственного экземпляра репозиториев и сервисов.

- Spring Boot автоматически создает синглтоны для всех компонентов
- Обеспечивает единое хранилище данных в памяти
- Предотвращает несогласованность данных
- Упрощает управление состоянием приложения

## Принципы SOLID

### S - Single Responsibility Principle
- **EntityFactory** - только создание и валидация объектов
- **BankAccountRepository** - только хранение счетов
- **IncomeExpenseDifferenceStrategy** - только один тип аналитики
- **TimingDecorator** - только измерение времени
- Каждый класс имеет одну причину для изменения

### O - Open/Closed Principle
- **Стратегии аналитики**: можно добавлять новые стратегии без изменения существующего кода
- **Посетители экспорта**: новые форматы добавляются через новые классы
- **Декораторы команд**: новая функциональность добавляется через декораторы
- Система открыта для расширения, закрыта для модификации

### L - Liskov Substitution Principle
- Все реализации `AnalyticsStrategy` взаимозаменяемы
- `JsonImporter` и `CsvImporter` могут использоваться вместо `DataImporter`
- Любой `ExportVisitor` работает с `ExportService`

### I - Interface Segregation Principle
- `Command` - минималистичный интерфейс с одним методом `execute()`
- `AnalyticsStrategy` - фокусируется только на вычислении аналитики
- `ExportVisitor` - только методы для экспорта
- Клиенты не зависят от методов, которые не используют

### D - Dependency Inversion Principle
- Фасады зависят от абстракций (интерфейсов репозиториев через Spring)
- `AnalyticsFacade` зависит от `AnalyticsStrategy`, а не от конкретных стратегий
- `ExportService` зависит от `ExportVisitor`, а не от конкретных посетителей
- Высокоуровневые модули не зависят от низкоуровневых

## Принципы GRASP

### High Cohesion
- Каждый фасад содержит только методы для работы со своей сущностью
- Стратегии аналитики содержат только логику вычислений
- Репозитории содержат только логику хранения
- Связанная функциональность сгруппирована в одном месте

### Low Coupling (Слабая связанность)
- Фасады не зависят друг от друга напрямую
- Стратегии независимы друг от друга
- Посетители не знают о внутренней структуре моделей
- Минимальные зависимости между модулями облегчают тестирование и поддержку

## Использование DI-контейнера

Проект использует **Spring Boot** для Dependency Injection:
- Все репозитории помечены `@Repository`
- Все сервисы и фасады помечены `@Service` или `@Component`
- Spring автоматически управляет жизненным циклом бинов
- Зависимости внедряются через конструктор (`@RequiredArgsConstructor` от Lombok)
